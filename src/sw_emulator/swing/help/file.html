<html>
  <head>
    <title>JC64dis</title>
    <meta content="JC64dis">
    <style></style>
  </head>
  <body>
  <h1 align="center">JC64dis File menu</h1>
  <p>The file menu is dedicated to the project, and so have many voices:<br></p>
  <p align="center"><img src="./file1.png"></p>  
  <p align="center"><img src="./file2.png"></p>    
  <h2>New project</h2>
  <p>To use the disassembler it is necessary to be inside a project, so creating a new one is the fist step to do.<br></p>
  <p align="center"><img src="./project1.png"></p>
  The project windows gives you the ability to insert:
    <ul>
     <li><b>Project name:</b> a name to give to the project</li>
     <li><b>File to disassemblate:</b> it let you choose the file that you want to disassemblate. Once done, you will see the type (SID, MUS, PRG, MPG, CRT, VSF) detected and some information extracted from the file. In case of a cartridge you have to select the number of chip to disassemblate using the spinner</li>
     <li><b>Target maschine:</b> for program file you can choose the target machine to use in disassembler from:
         <ul>
             <li><b>C64</b></li>
             <li><b>C1541</b></li>
             <li><b>C128</b></li>
             <li><b>VIC20</b></li>
             <li><b>PLUS4</b></li>
         </ul>
         This selection will activate specific comments to know memory locations of each machine. 
         In Option panel you can select for each machine what range of memory location must be commented automatically.
     </li>
     <li><b>SIDLD memory flags:</b> this file were generated by some modified version of SidLength Detector wrote by Michael Schwendt and that myself patched into libsidplay in order to create such memory dump.<br>
         The idea were simple: let play a tune of a SID and collect if a given address is of a code or a data or never utilizated. With those flags you can achieve two important step:
           <ol>
           <li>Make at 0 to all the binary locations in SID files not used and being sure that the tune still play correctly. That file can be then compressed more better and I use a lot for saving byte in 4KB/16KB competition!</li>
           <li>Let an disassembler to know if it has to decode a part as of data or as of code.</li>
           </ol>
         If you have such files you can simple use <b>Add next</b> button to add one by one. If you want to reset the situation, just use the <b>clear</b>
          button or if you want a memory marked as all of code, than use <b>init</b> button.<br>
          Take present that you must apply the use of SIDLD with the function into the option menu
     </li>
     <li><b>Edit Constant Table:</b> create constants of max 5 chars that you can associate to better format the code.
     <p align="center"><img src="./constant1.png"></p>    
     </li>
     <li><b>Edit Relocate table:</b> you can insert a list of addresses that are code relocated.<br>
         For example: this code takes the contents from $8000 to $8CFF and relocates it to $C000:$CCFF
         <p align="center"><img src="./project2.png"></p>
         <p align="center"><img src="./project3.png"></p>
         <p align="center"><img src="./project4.png"></p>
         Now you can makes as garbage the code from $8000 that refers to code relocated in $C000 and continue to works on $C000 analysis.<br>
         The disadvantage of this is that the source code you obtain can not be compiled back to the original binary form.<br>
         Due to the nature of relocation implementation, when you apply a relocation address it copies the value from one position to another position in memory, so the order of application is important in case of multiple relocation. 
         For this once added you cannot delete the relocations, so before adding it, save the project and reopen it if the relocation is wrong.
     </li>  
    </ul>
  <h2>Open project</h2>
  <p>The function let you open a previusly salved project by read a .dis file.<br>
  Only one project can be opened at time, so you have to close the previous before opening a new one.</p>
   <h2>Close project</h2>
 <p>  This function let you close the current project to work with a new one.<br>
  If you had not saved it, you can still save it bebore closing.</p>
  <h2>Save project</h2>
  <p>Save the project to the current .dis file being in use.</p>
   <h2>Save as project</h2>
  <p>Save the project to a .dis file that you choose or create as new.</p> 
  
  <h2>Apply SIDlD memory flags to memory</h2>
  <p>If you have associated some SIDLD files to the project, here you can apply them to the memory location, so you will get the code/data part compiled in automatic.
   The program takes your confirmation before going on.
  </p>
  
   <h2>Create a MPR archive</h2>
   <p>The MPR is a custom files that contains many PRGs inside, so you can disassembly all files together.<br>
       This is usefull when you have some files from disk or tape that load itself in different part of the memory: you can so disassembly the memory with all the programs inside.<br>
       This means that one program should start and end before the starting of another peaces, otherwise the common memory is filled with the last read one.<br>
       For creating the MPR archive you should select all PRG files with CRTL+click from the file selector, then you should insert the name of resulting MPR archive.
   </p>  
   
   <h2>Collaborative merge</h2> 
   Suppose you are working in a team for disassembly for example a game. One people will follow the music, one people the graphics, and so on.<br>
   You need to create the project for that program and then give a copy to each people of the team to work on.<br>
   When all people has worked to their peace, you need to use this function to merge your work with all the other. Your work is so the primary and all the other the secondary.
   <br>
   The idea is that if you apply something to a memory location (make labels, comments, data/code assigment and so on) this will not be altered by secondary files, 
   otherwise the value of secodary file being imported will be used.<br>   
   The resulting project file is now the merge of all works and you can see all contribution together.
   
  <h2>Exit</h2>
  <p>This exit the application.</p>  
   <hr>
    <p align="center"><a href="./index.html"><img src="back.png" alt="Back" width="51" height="23" align="middle" border="0"></a></p>
  </body>
</html>
